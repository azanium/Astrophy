//
//  TVGuideInteractor.swift
//  Astro
//
//  Created by Suhendra Ahmad on 9/20/17.
//  Copyright (c) 2017 Ainasoft. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol TVGuideBusinessLogic
{
    func fetchChannels(request: TVGuide.Channels.Request)
    func sortChannelNumbers(request: TVGuide.Sort.Request)
    func sortChannelNames(request: TVGuide.Sort.Request)
}

protocol TVGuideDataStore
{
    var pagedChannels: PagedChannels { get set }
    var channels: [ChannelMeta] { get set }
}

class TVGuideInteractor: TVGuideBusinessLogic, TVGuideDataStore
{
    var presenter: TVGuidePresentationLogic?
    var worker: TVGuideWorker? = TVGuideWorker()
    var pagedChannels: PagedChannels = PagedChannels()
    var channels = [ChannelMeta]()
    
    // MARK: Do something
    
    func fetchChannels(request: TVGuide.Channels.Request) {
        if pagedChannels.pageCount == 0 {
            fetchAllChannelIds() { (pagedChannels) in
                self.pagedChannels = pagedChannels
                self.pagedChannels.currentPage = request.page
                
                self.loadChannelsMeta(request: request)
            }
        }
        else {
            self.loadChannelsMeta(request: request)
        }
    }
    
    func loadChannelsMeta(request: TVGuide.Channels.Request) {
        let pageData = self.pagedChannels.pages[request.page - 1]
        worker?.fetchChannelMetas(ids: pageData.channelIds) { (response) in
            switch response {
            case .success(let channels):
                for ch in channels {
                    self.channels += [ch]
                }
                self.loadProgrammes(channels: channels, page: request.page, startDate: request.startDate, endDate: request.endDate)
                
            case .error(let message):
                print("# error: TVGuideInteractor.fetchChannels(): \(message)")
            }
        }
    }
    
    func loadProgrammes(channels: [ChannelMeta], page: Int, startDate: String, endDate: String) {
        let pageData = self.pagedChannels.pages[page - 1]
        worker?.fetchEvents(ids: pageData.channelIds, startDate: startDate, endDate: endDate) { (response) in
            
            switch response {
            case .success(let events):
                
                let nextPage = min(page + 1, self.pagedChannels.pageCount)
                let resp = TVGuide.Channels.Response(channels: channels, currentPage: nextPage, pageCount: self.pagedChannels.pageCount, events: events)
                self.presenter?.presentChannels(response: resp)
                
                
            case .error(let message):
                print("# error: TVGuideInteractor.fetchChannels(): \(message)")
            }
        }
    }
    
    func fetchAllChannelIds(completionHandler: ((PagedChannels)->Void)?) {
        worker?.fetchChannels() { (response) in
            switch response {
            case .success(let channels):
                let pageChannels = PagedChannels()
                pageChannels.importChannels(channels: channels, rowsPerPage: 10)
                completionHandler?(pageChannels)
                
            case .error(_):
                print("error")
            }
        }
    }
    
    func sortChannelNumbers(request: TVGuide.Sort.Request) {
        channels.sort { (ch1, ch2) -> Bool in
            request.ascending ? ch1.channelStubNumber < ch2.channelStubNumber : ch1.channelStubNumber > ch2.channelStubNumber
        }
        
        self.loadProgrammes(channels: channels, page: pagedChannels.currentPage, startDate: request.startDate, endDate: request.endDate)
    }
    
    func sortChannelNames(request: TVGuide.Sort.Request) {
        channels.sort { (ch1, ch2) -> Bool in
            request.ascending ? ch1.channelTitle < ch2.channelTitle : ch1.channelTitle > ch2.channelTitle
        }
        
        self.loadProgrammes(channels: channels, page: pagedChannels.currentPage, startDate: request.startDate, endDate: request.endDate)
    }

}
